#lang racket
(provide normalize-context)
(require "utils.rkt")
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <exp>))*) <exp>)
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  <label>
;;        |  (if <exp> <exp> <exp>)
;;        |  (begin <exp>+)
;;        |  (let ((<uvar> <exp>)*) <exp>)
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp> <exp>*)
(define (normalize-context program)
  (define (make-begin effect* e)
    (if (null? effect*)
        e
        `(begin ,@effect* ,e)))
  (define (make-nopless-begin effect* e)
    (if (equal? e '(nop))
        (make-effect effect*)
        (let ((effect* (remove-all '(nop) effect*)))
          (make-begin effect* e))))
  (define (make-pred value)
    `(if (eq? ,value '#f) (false) (true)))
  (define (make-effect effect*)
    (let ((effect* (remove-all '(nop) effect*)))
      (cond ((null? effect*) '(nop))
            ((null? (cdr effect*)) (car effect*))
            (else `(begin . ,effect*)))))
  (define (If Context pred a e)
    (match pred
      ((true) (Context a))
      ((false) (Context e))
      ((begin . ,exp+)
       (:begin exp+
               (lambda (effect* pred)
                 (make-begin
                  effect*
                  (If Context pred a e)))))
      ((let ,bds ,pred)
       (: bds
          (lambda (x* e*)
            (Let x* e*
                 (If Context pred a e)))))
      (,else
       `(if ,pred ,(Context a) ,(Context e)))))
  (define (Begin Context exp+)
    (:begin exp+
            (lambda (exp* exp)
              (let ((effect* (map Effect exp*))
                    (exp (Context exp)))
                (make-nopless-begin effect* exp)))))
  (define (Leto Context bds body)
    (: bds
       (lambda (x* e*)
         (let ((e* (map Value e*))
               (body (Context body)))
           (Let x* e* body)))))
  (define (Value exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) (If Value (Pred q) a e))
      ((begin . ,exp+) (Begin Value exp+))
      ((let ,bds ,body) (Leto Value bds body))
      ((,prim . ,rands)
       (guard (prim+? prim))
       (define value* (map Value rands))
       (define prim-app (cons prim value*))
       (cond ((value-prim? prim) prim-app)
             ((pred-prim? prim)
              `(if ,prim-app '#t '#f))
             ((effect-prim? prim)
              `(begin ,prim-app (void)))))
      ((,rator . ,rands)
       (map Value exp))))
  (define value-true-prims
    '(+ - * cons make-vector vector-length box void make-procedure procedure-code))
  (define value-true-prim?
    (make-predicate value-true-prims))
  (define value-unknown-prims
    '(car cdr vector-ref unbox procedure-ref))
  (define value-unknown-prim?
    (make-predicate value-unknown-prims))
  (define (Pred exp)
    (match exp
      ((quote ,i)
       (if (eq? i #f) '(false) '(true)))
      (,x (guard (symbol? x)) (make-pred x))
      ((if ,q ,a ,e) (If Pred (Pred q) a e))
      ((begin . ,exp+) (Begin Pred exp+))
      ((let ,bds ,body) (Leto Pred bds body))
      ((,prim . ,rands)
       (guard (prim+? prim))
       (if (value-true-prim? prim)
           (let ((effect* (map Effect rands)))
             (make-nopless-begin
              effect* '(true)))
           (let* ((value* (map Value rands))
                  (prim-app (cons prim value*)))
             (cond ((value-unknown-prim? prim)
                    (make-pred prim-app))
                   ((pred-prim? prim) prim-app)
                   ((effect-prim? prim)
                    `(begin ,prim-app (true)))))))
      ((,rator . ,rands)
       (make-pred (map Value exp)))))
  (define (Effect exp)
    (match exp
      ((quote ,i) '(nop))
      (,x (guard (symbol? x)) '(nop))
      ((if ,q ,a ,e) (If Effect (Pred q) a e))
      ((begin . ,exp+) (Begin Effect exp+))
      ((let ,bds ,body) (Leto Effect bds body))
      ((,prim . ,rands)
       (guard (prim+? prim))
       (cond ((value-prim? prim)
              ;not right, but acceptable
              (let ((effect* (map Effect rands)))
                (make-effect effect*)))
             ((pred-prim? prim)
              ;not right, but acceptable
              (let ((effect* (map Effect rands)))
                (make-effect effect*)))
             ((effect-prim? prim)
              (let ((value* (map Value rands)))
                (cons prim value*)))))
      ((,rator . ,rands)
       (map Value exp))))
  (match program
    ((letrec ,bds ,body)
     (: bds
        (lambda (x* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              `(lambda ,x* ,(Value body)))))
                         e*))
                (body (Value body)))
            (Letrec x* e* body)))))))
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <value>))*) <value>)
;; <value> ::= (quote <immediate>)
;;          |  <uvar>
;;          |  <label>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (let ((<uvar> <value>)*) <value>)
;;          |  (<value-prim> <value>*)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (let ((<uvar> <value>)*) <pred>)
;;         |  (<pred-prim> <value>*)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (let ((<uvar> <value>)*) <effect>)
;;           |  (<effect-prim> <value>*)
;;           |  (<value> <value> <value>*)