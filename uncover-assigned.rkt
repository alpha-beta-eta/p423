#lang racket
(provide uncover-assigned)
(require "utils.rkt")
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (set! <uvar> <exp>)
;;        |  (begin <exp>+)
;;        |  (lambda (<uvar>*) <exp>)
;;        |  (let ((<uvar> <exp>)*) <exp>)
;;        |  (letrec ((<uvar> <exp>)*) <exp>)
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)
;; <immediate> ::= ()
;;              |  <boolean>
;;              |  <fixnum>
(define (uncover-assigned exp)
  (define (uncover* exp*)
    (if (null? exp*)
        (values '() '())
        (let-values (((exp u*) (uncover (car exp*)))
                     ((exp* v*) (uncover* (cdr exp*))))
          (values (cons exp exp*) (U u* v*)))))
  (define (uncover exp)
    (match exp
      ((quote ,i) (values exp '()))
      (,uvar (guard (symbol? uvar)) (values exp '()))
      ((if ,q ,a ,e)
       (let-values (((qae u*) (uncover* (cdr exp))))
         (values (cons 'if qae) u*)))
      ((set! ,uvar ,exp)
       (let-values (((exp u*) (uncover exp)))
         (values `(set! ,uvar ,exp)
                 (set-cons uvar u*))))
      ((begin . ,exp*)
       (let-values (((exp* u*) (uncover* exp*)))
         (values (cons 'begin exp*) u*)))
      ((lambda ,x* ,body)
       (let-values (((body u*) (uncover body)))
         (values `(lambda ,x*
                    (assigned ,(I x* u*) ,body))
                 (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*) (uncover* e*))
                         ((body v*) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* v*) ,body))
                      (U u* (D v* x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*) (uncover* e*))
                         ((body v*) (uncover body)))
              (define w* (U u* v*))
              (values (Letrec x* e* `(assigned ,(I x* w*) ,body))
                      (D w* x*))))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (let-values (((rands u*) (uncover* rands)))
         (values `(,prim . ,rands) u*)))
      ((,rator . ,rands) (uncover* exp))))
  (let-values (((exp u*) (uncover exp)))
    (if (null? u*)
        exp
        (error 'uncover-assigned "unbound assigned variables ~s" u*))))
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (set! <uvar> <exp>)
;;        |  (begin <exp>+)
;;        |  (lambda (<uvar>*) (assigned (<uvar>*) <exp>))
;;        |  (let ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;;        |  (letrec ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)