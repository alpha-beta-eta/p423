#lang racket
(provide remove-let)
(require "utils.rkt")
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (let ((<uvar> <value>)*) <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (let ((<uvar> <value>)*) <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (let ((<uvar> <value>)*) <effect>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value> <value>*)
;; <body> ::= (locals (<uvar>*) <value>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=
(define (remove-let program)
  (define (If Context pred e1 e2)
    `(if ,(Pred pred) ,(Context e1) ,(Context e2)))
  (define (Begin Context exp+)
    (:begin exp+
            (lambda (exp* exp)
              (let ((exp* (map Effect exp*))
                    (exp (Context exp)))
                (make-begin exp* exp)))))
  (define (Leto Context bds body)
    (: bds
       (lambda (x* e*)
         (let ((e* (map Value e*))
               (body (Context body)))
           (make-begin
            (map (lambda (x e)
                   `(set! ,x ,e))
                 x* e*)
            body)))))
  (define (Op op . v*)
    (cons op (map Value v*)))
  (define (Value value)
    (match value
      (,triv (guard (not (pair? triv))) triv)
      ((if ,pred ,v1 ,v2) (If Value pred v1 v2))
      ((begin . ,exp+) (Begin Value exp+))
      ((let ,bds ,body) (Leto Value bds body))
      ((alloc ,v) (Op 'alloc v))
      ((mref ,v1 ,v2) (Op 'mref v1 v2))
      ((,binop ,v1 ,v2)
       (guard (binop? binop))
       (Op binop v1 v2))
      ((,rator . ,rands) (map Value value))))
  (define (Pred pred)
    (match pred
      ((true) '(true))
      ((false) '(false))
      ((if ,p1 ,p2 ,p3) (If Pred p1 p2 p3))
      ((begin . ,exp+) (Begin Pred exp+))
      ((let ,bds ,body) (Leto Pred bds body))
      ((,relop ,v1 ,v2)
       (guard (relop? relop))
       (Op relop v1 v2))))
  (define (Effect effect)
    (match effect
      ((nop) '(nop))
      ((if ,pred ,e1 ,e2) (If Effect pred e1 e2))
      ((begin . ,exp+) (Begin Effect exp+))
      ((let ,bds ,body) (Leto Effect bds body))
      ((mset! ,v1 ,v2 ,v3) (Op 'mset! v1 v2 v3))
      ((,rator . ,rands) (map Value effect))))
  (define (Body body)
    (match body
      ((locals ,x* ,value)
       `(locals ,x* ,(Value value)))))
  (match program
    ((letrec ,bds ,body)
     (: bds
        (lambda (x* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              `(lambda ,x* ,(Body body)))))
                         e*))
                (body (Body body)))
            (Letrec x* e* body)))))))
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <value>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value> <value>*)
;; <body> ::= (locals (<uvar>*) <value>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=
;;
;; or equivalently, just in order to distinguish <tail> from <value>
;;
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <value>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value> <value>*)
;; <tail> ::= <triv>
;;         |  (if <pred> <tail> <tail>)
;;         |  (begin <effect>* <tail>)
;;         |  (alloc <value>)
;;         |  (mref <value> <value>)
;;         |  (<binop> <value> <value>)
;;         |  (<value> <value> <value>*)
;; <body> ::= (locals (<uvar>*) <tail>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=