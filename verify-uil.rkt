#lang racket
(provide verify-uil)
(require "utils.rkt")
;; UIL = Universal Intermediate Language
;; This pass is just to verify the input and does not change the syntax.
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <value>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value> <value>*)
;; <tail> ::= <triv>
;;         |  (if <pred> <tail> <tail>)
;;         |  (begin <effect>* <tail>)
;;         |  (alloc <value>)
;;         |  (mref <value> <value>)
;;         |  (<binop> <value> <value>)
;;         |  (<value> <value> <value>*)
;; <body> ::= (locals (<uvar>*) <tail>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=
(define (verify-uil program)
  (define (triv? triv)
    (or (int64? triv)
        (uvar? triv)
        (label? triv)))
  (define (make-begin exp* exp)
    `(begin ,@exp* ,exp))
  (define (If Context pred e1 e2)
    `(if ,(Pred pred) ,(Context e1) ,(Context e2)))
  (define (Begin Context exp+)
    (:begin exp+
            (lambda (exp* exp)
              (let ((exp* (map Effect exp*))
                    (exp (Context exp)))
                (make-begin exp* exp)))))
  (define (Op op . v*)
    (cons op (map Value v*)))
  (define (Value value)
    (match value
      (,triv
       (guard (not (pair? triv)))
       (if (triv? triv)
           triv
           (error 'verify-uil "unknown triv ~s" triv)))
      ((if ,pred ,v1 ,v2) (If Value pred v1 v2))
      ((begin . ,exp+) (Begin Value exp+))
      ((alloc ,v) (Op 'alloc v))
      ((mref ,v1 ,v2) (Op 'mref v1 v2))
      ((,binop ,v1 ,v2)
       (guard (binop? binop))
       (Op binop v1 v2))
      ((,rator ,rand . ,rands) (map Value value))))
  (define (Pred pred)
    (match pred
      ((true) '(true))
      ((false) '(false))
      ((if ,p1 ,p2 ,p3) (If Pred p1 p2 p3))
      ((begin . ,exp+) (Begin Pred exp+))
      ((,relop ,v1 ,v2)
       (guard (relop? relop))
       (Op relop v1 v2))))
  (define (Effect effect)
    (match effect
      ((nop) '(nop))
      ((if ,pred ,e1 ,e2) (If Effect pred e1 e2))
      ((begin . ,exp+) (Begin Effect exp+))
      ((set! ,x ,v)
       (guard (uvar? x))
       `(set! ,x ,(Value v)))
      ((mset! ,v1 ,v2 ,v3) (Op 'mset! v1 v2 v3))
      ((,rator ,rand . ,rands) (map Value effect))))
  (define (Tail tail)
    (match tail
      (,triv
       (guard (not (pair? triv)))
       (if (triv? triv)
           triv
           (error 'verify-uil "unknown triv ~s" triv)))
      ((if ,pred ,t1 ,t2) (If Tail pred t1 t2))
      ((begin . ,exp+) (Begin Tail exp+))
      ((alloc ,v) (Op 'alloc v))
      ((mref ,v1 ,v2) (Op 'mref v1 v2))
      ((,binop ,v1 ,v2)
       (guard (binop? binop))
       (Op binop v1 v2))
      ((,rator ,rand . ,rands) (map Value tail))))
  (define (Body body)
    (match body
      ((locals ,x* ,tail)
       `(locals ,x* ,(Tail tail)))))
  (match program
    ((letrec ,bds ,body)
     (: bds
        (lambda (x* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              (guard (pair? x*))
                              `(lambda ,x* ,(Body body)))))
                         e*))
                (body (Body body)))
            (Letrec x* e* body)))))))
;; But, we will use a slightly more general syntax since then.
;; <program> ::= (letrec ((<label> (lambda (<uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <value>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value>*)
;; <tail> ::= <triv>
;;         |  (if <pred> <tail> <tail>)
;;         |  (begin <effect>* <tail>)
;;         |  (alloc <value>)
;;         |  (mref <value> <value>)
;;         |  (<binop> <value> <value>)
;;         |  (<value> <value>*)
;; <body> ::= (locals (<uvar>*) <tail>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=