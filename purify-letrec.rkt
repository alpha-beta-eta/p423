#lang racket
(provide purify-letrec)
(require "utils.rkt")
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (set! <uvar> <exp>)
;;        |  (begin <exp>+)
;;        |  (lambda (<uvar>*) (assigned (<uvar>*) <exp>))
;;        |  (let ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;;        |  (letrec ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)
(define (purify-letrec exp)
  (define (purify exp)
    (match exp
      ((quote ,i) exp)
      (,uvar (guard (symbol? uvar)) uvar)
      ((if ,q ,a ,e)
       (cons 'if (map purify (cdr exp))))
      ((set! ,uvar ,exp)
       `(set! ,uvar ,(purify exp)))
      ((begin . ,exp*)
       (cons 'begin (map purify exp*)))
      ((lambda ,x* (assigned ,u* ,body))
       `(lambda ,x*
          (assigned ,u* ,(purify body))))
      ((let ,bds (assigned ,u* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* `(assigned ,u* ,body))))))
      ((letrec ,bds (assigned ,u* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (define (assigned? x) (memq x u*))
              (define (bound? x) (memq x x*))
              (define (lambda? e)
                (and (pair? e)
                     (eq? (car e) 'lambda)))
              (define (simple? e)
                (match e
                  ((quote ,i) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((if . ,e*) (andmap simple? e*))
                  ((begin . ,e*) (andmap simple? e*))
                  ((,prim . ,e*)
                   (guard (prim? prim))
                   (andmap simple? e*))
                  (,else #f)))
              (define (Leta x* e* u* body)
                (if (null? x*)
                    body
                    `(let ,(map list x* e*)
                       (assigned ,u* ,body))))
              (let iter ((x* x*)
                         (e* e*)
                         (xs* '())
                         (es* '())
                         (xl* '())
                         (el* '())
                         (xc* '())
                         (ec* '()))
                (if (null? x*)
                    (let ((xt* (map (lambda (x)
                                      (unique-symbol 't))
                                    xc*)))
                      (Leta
                       xs* es* '()
                       (Leta
                        xc* (map (lambda (x) '(void)) xc*) xc*
                        (Letrec
                         xl* el*
                         (Leta
                          xt* ec* '()
                          `(begin
                             ,@(map (lambda (xc xt)
                                      `(set! ,xc ,xt))
                                    xc* xt*)
                             ,body))))))
                    (let ((x (car x*))
                          (x* (cdr x*))
                          (e (car e*))
                          (e* (cdr e*)))
                      (cond ((assigned? x)
                             (iter x* e* xs* es* xl* el*
                                   (cons x xc*) (cons e ec*)))
                            ((lambda? e)
                             (iter x* e* xs* es*
                                   (cons x xl*) (cons e el*)
                                   xc* ec*))
                            ((simple? e)
                             (iter x* e*
                                   (cons x xs*) (cons e es*)
                                   xl* el* xc* ec*))
                            (else
                             (iter x* e* xs* es* xl* el*
                                   (cons x xc*) (cons e ec*)))))))))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map purify rands)))
      ((,rator . ,rands)
       (map purify exp))))
  (purify exp))
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (set! <uvar> <exp>)
;;        |  (begin <exp>+)
;;        |  (lambda (<uvar>*) (assigned (<uvar>*) <exp>))
;;        |  (let ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;;        |  (letrec ((<uvar> (lambda (<uvar>*) (assigned (<uvar>*) <exp>)))*) <exp>)
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)