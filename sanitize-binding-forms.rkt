#lang racket
(provide sanitize-binding-forms)
(require "utils.rkt")
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (begin <exp>+)
;;        |  (let ((<uvar> <exp0>)*) <exp>)
;;        |  (letrec ((<uvar> <lam>)*) <exp>)
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)
;; <exp0> ::= <lam> | <exp>
;; <lam> ::= (lambda (<uvar>*) <exp>)
(define (sanitize-binding-forms exp)
  (define (Let x* e* body)
    (if (null? x*)
        body
        `(let ,(map list x* e*) ,body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        `(letrec ,(map list x* e*) ,body)))
  (define (make-begin exp*)
    (let ((exp* (append-map
                 (lambda (exp)
                   (match exp
                     ((begin . ,exp*) exp*)
                     (,else (list exp))))
                 exp*)))
      (if (null? (cdr exp*))
          (car exp*)
          (cons 'begin exp*))))
  (define (lambda? exp)
    (and (pair? exp)
         (eq? (car exp) 'lambda)))
  (define (sanitize exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e)
       (cons 'if (map sanitize (cdr exp))))
      ((begin . ,exp*)
       (make-begin (map sanitize exp*)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(sanitize body)))
                               (,else (sanitize e))))
                           e*))
                  (body (sanitize body)))
              (let iter ((x* x*)
                         (e* e*)
                         (xo* '())
                         (eo* '())
                         (xl* '())
                         (el* '()))
                (if (null? x*)
                    (Letrec
                     xl* el*
                     (Let xo* eo* body))
                    (let ((x (car x*))
                          (x* (cdr x*))
                          (e (car e*))
                          (e* (cdr e*)))
                      (if (lambda? e)
                          (iter x* e* xo* eo*
                                (cons x xl*) (cons e el*))
                          (iter x* e* (cons x xo*) (cons e eo*)
                                xl* el*)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(sanitize body)))))
                           e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map sanitize rands)))
      ((,rator . ,rands)
       (map sanitize exp))))
  (sanitize exp))
#;
(define (make-begin exp*)
  (define (flatten exp*)
    (append-map
     (lambda (exp)
       (match exp
         ((begin . ,exp*) (flatten exp*))
         (,else (list exp))))
     exp*))
  (let ((exp* (flatten exp*)))
    (if (null? (cdr exp*))
        (car exp*)
        (cons 'begin exp*))))
;; <exp> ::= (quote <immediate>)
;;        |  <uvar>
;;        |  (if <exp> <exp> <exp>)
;;        |  (begin <exp>+)
;;        |  (let ((<uvar> <exp>)*) <exp>)
;;        |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;;        |  (<prim> <exp>*)
;;        |  (<exp> <exp>*)