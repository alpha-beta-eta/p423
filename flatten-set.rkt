#lang racket
(provide flatten-set!)
(require "utils.rkt")
;; <program> ::= (letrec ((<label> (lambda (<uvar>*) <body>))*) <body>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (alloc <triv>)
;;          |  (mref <triv> <triv>)
;;          |  (<binop> <triv> <triv>)
;;          |  (<triv> <triv>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <triv> <triv>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <value>)
;;           |  (mset! <triv> <triv> <triv>)
;;           |  (<triv> <triv>*)
;; <tail> ::= <triv>
;;         |  (if <pred> <tail> <tail>)
;;         |  (begin <effect>* <tail>)
;;         |  (alloc <triv>)
;;         |  (mref <triv> <triv>)
;;         |  (<binop> <triv> <triv>)
;;         |  (<triv> <triv>*)
;; <body> ::= (locals (<uvar>*) <tail>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=
(define (flatten-set! program)
  (define (If Context pred e1 e2)
    `(if ,(Pred pred) ,(Context e1) ,(Context e2)))
  (define (Begin Context exp+)
    (:begin exp+
            (lambda (exp* exp)
              (let ((exp* (map Effect exp*))
                    (exp (Context exp)))
                (make-begin exp* exp)))))
  (define (triv? x)
    (not (pair? x)))
  (define (simple? x)
    (match x
      (,triv (guard (triv? triv)) #t)
      ((alloc ,triv) (triv? triv))
      ((mref ,triv1 ,triv2)
       (and (triv? triv1) (triv? triv2)))
      ((,binop ,triv1 ,triv2)
       (guard (binop? binop))
       (and (triv? triv1) (triv? triv2)))
      ((,rator . ,rands) (andmap triv? x))))
  (define (make-set! x simple)
    (unless (simple? simple)
      (error 'flatten-set!
             "~s should be simple!"
             simple))
    `(set! ,x ,simple))
  (define ((simplize-set! x) value)
    (match value
      ((if ,pred ,v1 ,v2)
       (If (simplize-set! x) pred v1 v2))
      ((begin . ,exp+)
       (Begin (simplize-set! x) exp+))
      (,simple (make-set! x simple))))
  (define (Tail tail)
    (match tail
      ((if ,pred ,t1 ,t2) (If Tail pred t1 t2))
      ((begin . ,exp+) (Begin Tail exp+))
      (,simple (guard (simple? simple)) simple)))
  (define (Pred pred)
    (match pred
      ((true) '(true))
      ((false) '(false))
      ((if ,p1 ,p2 ,p3) (If Pred p1 p2 p3))
      ((begin . ,exp+) (Begin Pred exp+))
      ((,relop ,triv1 ,triv2)
       (guard (and (relop? relop)
                   (triv? triv1)
                   (triv? triv2)))
       pred)))
  (define (Effect effect)
    (match effect
      ((nop) '(nop))
      ((if ,pred ,e1 ,e2) (If Effect pred e1 e2))
      ((begin . ,exp+) (Begin Effect exp+))
      ((set! ,x ,v) ((simplize-set! x) v))
      ((mset! ,triv1 ,triv2 ,triv3)
       (guard (andmap triv? (cdr effect)))
       effect)
      ((,rator . ,rands)
       (guard (andmap triv? effect))
       effect)))
  (define (Body body)
    (match body
      ((locals ,x* ,tail)
       `(locals ,x* ,(Tail tail)))))
  (match program
    ((letrec ,bds ,body)
     (: bds
        (lambda (x* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              `(lambda ,x* ,(Body body)))))
                         e*))
                (body (Body body)))
            (Letrec x* e* body)))))))
;; <program> ::= (letrec ((<label> (lambda (<uvar>*) <body>))*) <body>)
;; <tail> ::= <triv>
;;         |  (if <pred> <tail> <tail>)
;;         |  (begin <effect>* <tail>)
;;         |  (alloc <triv>)
;;         |  (mref <triv> <triv>)
;;         |  (<binop> <triv> <triv>)
;;         |  (<triv> <triv>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (<relop> <triv> <triv>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (set! <uvar> <simple>)
;;           |  (mset! <triv> <triv> <triv>)
;;           |  (<triv> <triv>*)
;; <simple> ::= <triv>
;;           |  (alloc <triv>)
;;           |  (mref <triv> <triv>)
;;           |  (<binop> <triv> <triv>)
;;           |  (<triv> <triv>*)
;; <body> ::= (locals (<uvar>*) <tail>)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=