#lang racket
(provide specify-representation)
(require "utils.rkt")
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <value>))*) <value>)
;; <value> ::= (quote <immediate>)
;;          |  <uvar>
;;          |  <label>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (let ((<uvar> <value>)*) <value>)
;;          |  (<value-prim> <value>*)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (let ((<uvar> <value>)*) <pred>)
;;         |  (<pred-prim> <value>*)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (let ((<uvar> <value>)*) <effect>)
;;           |  (<effect-prim> <value>*)
;;           |  (<value> <value> <value>*)
(define (specify-representation program)
  (define Value-prim
    (case-lambda
      ((void) $void)
      ((uop x)
       (case uop
         ((car) `(mref ,x ,(- offset:car tag:pair)))
         ((cdr) `(mref ,x ,(- offset:cdr tag:pair)))
         ((make-vector)
          (define vect (unique-symbol 'vec))
          (cond ((number? x)
                 `(let ((,vect (+ (alloc ,(+ offset:vector-data x)) ,tag:vector)))
                    (begin
                      (mset! ,vect ,(- offset:vector-length tag:vector) ,x)
                      ,vect)))
                ((symbol? x)
                 `(let ((,vect (+ (alloc (+ ,offset:vector-data ,x)) ,tag:vector)))
                    (begin
                      (mset! ,vect ,(- offset:vector-length tag:vector) ,x)
                      ,vect)))
                (else
                 (let ((lent (unique-symbol 'len)))
                   `(let ((,lent ,x))
                      (let ((,vect (+ (alloc (+ ,offset:vector-data ,lent)) ,tag:vector)))
                        (begin
                          (mset! ,vect ,(- offset:vector-length tag:vector) ,lent)
                          ,vect)))))))
         ((vector-length)
          `(mref ,x ,(- offset:vector-length tag:vector)))
         ((box)
          (define boxt (unique-symbol 'box))
          `(let ((,boxt (+ (alloc ,size:box) ,tag:box)))
             (begin
               (mset! ,boxt ,(- offset:box tag:box) ,x)
               ,boxt)))
         ((unbox)
          `(mref ,x ,(- offset:box tag:box)))
         ((procedure-code)
          `(mref ,x ,(- offset:procedure-code tag:procedure)))))
      ((binop x y)
       (case binop
         ((+) (if (and (number? x) (number? y))
                  (+ x y)
                  `(+ ,x ,y)))
         ((-) (if (and (number? x) (number? y))
                  (- x y)
                  `(- ,x ,y)))
         ((*) (cond ((and (number? x) (number? y))
                     (* x (sra y 3)))
                    ((number? x) `(* ,(sra x 3) ,y))
                    ((number? y) `(* ,x ,(sra y 3)))
                    (else `(* ,x (sra ,y 3)))))
         ((cons)
          (define pairt (unique-symbol 'pair))
          `(let ((,pairt (+ (alloc ,size:pair) ,tag:pair)))
             (begin
               (mset! ,pairt ,(- offset:car tag:pair) ,x)
               (mset! ,pairt ,(- offset:cdr tag:pair) ,y)
               ,pairt)))
         ((vector-ref)
          (if (number? y)
              `(mref ,x ,(+ (- offset:vector-data tag:vector) y))
              `(mref ,x (+ ,(- offset:vector-data tag:vector) ,y))))
         ((make-procedure)
          (define proct (unique-symbol 'proc))
          (if (and (label? x) (number? y))
              `(let ((,proct (+ (alloc ,(+ offset:procedure-data y)) ,tag:procedure)))
                 (begin
                   (mset! ,proct ,(- offset:procedure-code tag:procedure) ,x)
                   ,proct))
              (error 'specify-representation
                     "the arguments of make-procedure should be known at compile time")))
         ((procedure-ref)
          (if (number? y)
              `(mref ,x ,(+ (- offset:procedure-data tag:procedure) y))
              (error 'specify-representation
                     "procedure-ref: the loc of free var should be known at compile time")))))))
  (define Pred-prim
    (case-lambda
      ((predicate x)
       (define (make-pred mask tag)
         `(= (logand ,x ,mask) ,tag))
       (case predicate
         ((null?) `(= ,x ,$nil))
         ((boolean?) (make-pred mask:boolean tag:boolean))
         ((fixnum?) (make-pred mask:fixnum tag:fixnum))
         ((pair?) (make-pred mask:pair tag:pair))
         ((vector?) (make-pred mask:vector tag:vector))
         ((box?) (make-pred mask:box tag:box))
         ((procedure?) (make-pred mask:procedure tag:procedure))))
      ((compare x y)
       (case compare
         ((eq?) `(= ,x ,y))
         (else `(,compare ,x ,y))))))
  (define Effect-prim
    (case-lambda
      ((set obj val)
       (case set
         ((set-car!)
          `(mset! ,obj ,(- offset:car tag:pair) ,val))
         ((set-cdr!)
          `(mset! ,obj ,(- offset:cdr tag:pair) ,val))
         ((set-box!)
          `(mset! ,obj ,(- offset:box tag:box) ,val))))
      ((set obj loc val)
       (case set
         ((vector-set!)
          (if (number? loc)
              `(mset! ,obj ,(+ (- offset:vector-data tag:vector) loc) ,val)
              `(mset! ,obj (+ ,(- offset:vector-data tag:vector) ,loc) ,val)))
         ((procedure-set!)
          (if (number? loc)
              `(mset! ,obj ,(+ (- offset:procedure-data tag:procedure) loc) ,val)
              (error 'specify-representation
                     "procedure-set!: the loc of free var should be known at compile time")))))))
  (define (If Context pred e1 e2)
    `(if ,(Pred pred)
         ,(Context e1)
         ,(Context e2)))
  (define (Begin Context exp+)
    (:begin exp+
            (lambda (exp* exp)
              (let ((exp* (map Effect exp*))
                    (exp (Context exp)))
                (make-begin exp* exp)))))
  (define (Leto Context bds body)
    (: bds
       (lambda (x* e*)
         (let ((e* (map Value e*))
               (body (Context body)))
           (Let x* e* body)))))
  (define (Value value)
    (match value
      ((quote ,i)
       (cond ((eq? i #f) $false)
             ((eq? i #t) $true)
             ((eq? i '()) $nil)
             (else (ash i shift-fixnum))))
      (,x (guard (symbol? x)) x)
      ((if ,pred ,v1 ,v2) (If Value pred v1 v2))
      ((begin . ,exp+) (Begin Value exp+))
      ((let ,bds ,body) (Leto Value bds body))
      ((,value-prim . ,rands)
       (guard (value-prim? value-prim))
       (apply Value-prim
              value-prim
              (map Value rands)))
      ((,rator . ,rands)
       (map Value value))))
  (define (Pred pred)
    (match pred
      ((true) '(true))
      ((false) '(false))
      ((if ,p1 ,p2 ,p3) (If Pred p1 p2 p3))
      ((begin . ,exp+) (Begin Pred exp+))
      ((let ,bds ,body) (Leto Pred bds body))
      ((,pred-prim . ,rands)
       (guard (pred-prim? pred-prim))
       (apply Pred-prim
              pred-prim
              (map Value rands)))))
  (define (Effect effect)
    (match effect
      ((nop) '(nop))
      ((if ,pred ,e1 ,e2) (If Effect pred e1 e2))
      ((begin . ,exp+) (Begin Effect exp+))
      ((let ,bds ,body) (Leto Effect bds body))
      ((,effect-prim . ,rands)
       (guard (effect-prim? effect-prim))
       (apply Effect-prim
              effect-prim
              (map Value rands)))
      ((,rator . ,rands)
       (map Value effect))))
  (match program
    ((letrec ,bds ,body)
     (: bds
        (lambda (x* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              `(lambda ,x* ,(Value body)))))
                         e*))
                (body (Value body)))
            (Letrec x* e* body)))))))
;; <program> ::= (letrec ((<label> (lambda (<uvar> <uvar>*) <value>))*) <value>)
;; <value> ::= <triv>
;;          |  (if <pred> <value> <value>)
;;          |  (begin <effect>* <value>)
;;          |  (let ((<uvar> <value>)*) <value>)
;;          |  (alloc <value>)
;;          |  (mref <value> <value>)
;;          |  (<binop> <value> <value>)
;;          |  (<value> <value> <value>*)
;; <pred> ::= (true)
;;         |  (false)
;;         |  (if <pred> <pred> <pred>)
;;         |  (begin <effect>* <pred>)
;;         |  (let ((<uvar> <value>)*) <pred>)
;;         |  (<relop> <value> <value>)
;; <effect> ::= (nop)
;;           |  (if <pred> <effect> <effect>)
;;           |  (begin <effect>* <effect>)
;;           |  (let ((<uvar> <value>)*) <effect>)
;;           |  (mset! <value> <value> <value>)
;;           |  (<value> <value> <value>*)
;; <triv> ::= <int> | <uvar> | <label>
;; <binop> ::= + | - | * | sra | logand
;; <relop> ::= = | < | > | <= | >=